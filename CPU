#include <iostream>
#include <vector>
#include <cstdlib>
#include <ctime>
using namespace std;

struct Mydata {
    char lettera;
    int numero;
};

//dichiarazione punteggio carte
int calcolaPunteggio(const Mydata& carta) {
    switch(carta.numero) {
        case 1: return 11;   
        case 3: return 10;   
        case 10: return 4;  
        case 9: return 3; 
        case 8: return 2;   
        default: return 0;   // Altre carte
    }
}
//dichiarazione forza carte 
int forzaCarta(const Mydata& carta){
	switch (carta.numero){
		case 1: return 10; //asse
		case 3: return 9;  //tre
		case 10: return 8; //re
		case 9: return 7; //cavallo
		case 8: return 6; //fante
		case 7: return 5;
		case 6: return 4;
		case 5: return 3;
		case 4: return 2;
		case 2: return 1;
		default: return 0;
		
	}
}
bool cartaBriscola(const Mydata& carta, const Mydata& briscola) {
    int punti = calcolaPunteggio(carta);

    // non deve essere una briscola
    if (carta.lettera == briscola.lettera)
        return false;

    // liscio (0 punti)
    if (punti == 0)
        return true;

    // carico 2-3 punti (fante o cavallo)
    if (punti == 2 || punti == 3)
        return true;

    return false;
}



int main(){ //1v1; 1 umano contro la CPU
    setlocale(LC_ALL,"ita");
	srand(time(NULL));
    vector<Mydata> mazzo; //vector (mazzo totale) di struct
    vector <Mydata> mazzo_g1; //vector mazzo giocatore 1
    vector <Mydata> mazzo_g2; //vector mazzo CPU

    Mydata cartagiocata1, cartascelta1; //variabili giocatore 1
    int scelta1, punteggio1=0;
    Mydata cartagiocata2, cartascelta2; //variabili CPU
    int scelta2, punteggio2=0 ;
    Mydata cartagiocatab, cartasceltab; //variabili briscola
    int cartaTrovata;
    
    // Inserimento di alcuni elementi
    mazzo.push_back({'D', 1});//D= denari
    mazzo.push_back({'D', 2});
    mazzo.push_back({'D', 3});
    mazzo.push_back({'D', 4});
    mazzo.push_back({'D', 5});
    mazzo.push_back({'D', 6});
    mazzo.push_back({'D', 7});
    mazzo.push_back({'D', 8});
    mazzo.push_back({'D', 9});
    mazzo.push_back({'D', 10});
    mazzo.push_back({'C', 1});//C= coppe
    mazzo.push_back({'C', 2});
    mazzo.push_back({'C', 3});
    mazzo.push_back({'C', 4});
    mazzo.push_back({'C', 5});
    mazzo.push_back({'C', 6});
    mazzo.push_back({'C', 7});
    mazzo.push_back({'C', 8});
    mazzo.push_back({'C', 9});
    mazzo.push_back({'C', 10});
    mazzo.push_back({'B', 1});//B= bastoni
    mazzo.push_back({'B', 2});
    mazzo.push_back({'B', 3});
    mazzo.push_back({'B', 4});
    mazzo.push_back({'B', 5});
    mazzo.push_back({'B', 6});
    mazzo.push_back({'B', 7});
    mazzo.push_back({'B', 8});
    mazzo.push_back({'B', 9});
    mazzo.push_back({'B', 10});
    mazzo.push_back({'S', 1});//S= spade
    mazzo.push_back({'S', 2});
    mazzo.push_back({'S', 3});
    mazzo.push_back({'S', 4});
    mazzo.push_back({'S', 5});
    mazzo.push_back({'S', 6});
    mazzo.push_back({'S', 7});
    mazzo.push_back({'S', 8});
    mazzo.push_back({'S', 9});
    mazzo.push_back({'S', 10});
  

    // stampa mazzo totale
    for (const auto& elem : mazzo) {
        cout << "Seme: " << elem.lettera 
             << ", Numero: " << elem.numero << endl;
    }
    
    //BRISCOLA  
    int nb = mazzo.size(); // Genera un indice casuale compreso tra 0 e n-1
    int mazzocasualeb = rand() % nb; // rand() % n genera un numero casuale tra 0 e n-1
    
    Mydata cartapescatab = mazzo[mazzocasualeb];  // pesca il numero casuale dal vettore

	
   
    // Stampa  la carta
        cout << "La briscola è: " 
             << cartapescatab.lettera << " " 
             << cartapescatab.numero << endl;
             
    
        mazzo.erase(mazzo.begin() + mazzocasualeb);   // rimuove la carta dal mazzo dopo averla pescata:
        
     for(int turni=0; turni<20; turni++){
    
    
    // GIOCATORE 1
    
    cout<<"giocatore 1"<<endl;
    int n1 = mazzo.size(); // Genera un indice casuale compreso tra 0 e n-1
    
    for(int i=0; i<3; i++){
    int mazzocasuale1 = rand() % n1; // rand() % n genera un numero casuale tra 0 e n-1
    Mydata cartapescata1 = mazzo[mazzocasuale1];  // pesca il numero casuale dal vettore

	
	mazzo_g1.push_back(cartapescata1);
   
    // Stampa  la carta
        cout << "La carta casuale estratta : " 
             << cartapescata1.lettera << " " 
             << cartapescata1.numero << endl;
             
    
        mazzo.erase(mazzo.begin() + mazzocasuale1);   // rimuove la carta dal mazzo dopo averla pescata:
        
    if(mazzo_g1.size()==3){
	
    cout << "Carte rimaste nel mazzo: " << mazzo.size() << endl;

    cout<<"quale carta vuoi giocare (1, 2, 3) giocatore 1?"<<endl;
    cin >> scelta1;
    cartagiocata1 = mazzo_g1[scelta1-1];  // Prendi la carta scelta
    mazzo_g1.erase(mazzo_g1.begin() + scelta1-1);
    
     // stampa vector giocatore 1
     cout<<"giocatore 1 ti rimangono queste carte"<<endl;
    for (const auto& elem : mazzo_g1) {
        cout << "Seme: " << elem.lettera 
             << ", Numero: " << elem.numero << endl;
    }
}
}
        // GIOCATORE 2 = CPU
    cout<<"è il turno della CPU"<<endl;
    int n2 = mazzo.size(); // Genera un indice casuale compreso tra 0 e n-1
    
    for(int i=0; i<3; i++){
    int mazzocasuale2 = rand() % n2; // rand() % n genera un numero casuale tra 0 e n-1
    
    Mydata cartapescata2 = mazzo[mazzocasuale2];  // pesca il numero casuale dal vettore

	
	mazzo_g2.push_back(cartapescata2);
   
    // Stampa  la carta
        cout << "La carta messa dalla CPU è : " 
             << cartapescata2.lettera << " " 
             << cartapescata2.numero << endl;
             
        mazzo.erase(mazzo.begin() + mazzocasuale2);   // rimuove la carta dal mazzo dopo averla pescata:
    if(mazzo_g2.size()==3){
    
    cout << "Carte rimaste nel mazzo: " << mazzo.size() << endl;
    
//se GIOCATORE 1 gioca la briscola 
bool briscola = (cartagiocata1.lettera == cartapescatab.lettera);

bool cartaTrovata = false;

if (briscola) { //La CPU deve giocare una carta che non vale punti e non è di briscola (liscio)
    for (int i = 0; i < mazzo_g2.size(); i++) {
        if (mazzo_g2[i].lettera != cartapescatab.lettera && calcolaPunteggio(mazzo_g2[i]) == 0) {
			cartagiocata2 = mazzo_g2[i];
            mazzo_g2.erase(mazzo_g2.begin() + i);
            cartaTrovata = true;
            break;
        }
    }
}
}
if (!cartaTrovata){ //se non è possibile giocare carte "liscio" allora la CPU gioca una carta "carico" che vale dai 2 ai 4 punti e non deve essere di briscola
	for (int i=0; i<mazzo_g2.size(); i++){
		int punti = calcolaPunteggio(mazzo_g2[i]);
			if (mazzo_g2[i].lettera != cartapescatab.lettera && punti>=2 && punti<=4){
				cartagiocata2 = mazzo_g2[i];
				mazzo_g2.erase(mazzo_g2.begin() + i);
				cartaTrovata = true;
				break;
	}
}
}
if (!cartaTrovata){ //se non è possibile giocare carte "carico" allora la CPU gioca una carta di briscola che però è più bassa del re
	for (int i=0; i<mazzo_g2.size(); i++){
		int punti = calcolaPunteggio(mazzo_g2[i]);
			if (mazzo_g2[i].lettera == cartapescatab.lettera && punti<4){
				cartagiocata2 = mazzo_g2[i];
				mazzo_g2.erase(mazzo_g2.begin() + i);
				cartaTrovata = true;
				break;
			}	
	}
}
if (!cartaTrovata){ //se non è possibile giocare carte di briscola più basse del re, allora, la CPU gioca una carta "carico"
	for (int i=0; i<mazzo_g2.size(); i++){
		int punti = calcolaPunteggio(mazzo_g2[i]);
			if (mazzo_g2[i].lettera != cartapescatab.lettera && punti>=2){
				cartagiocata2 = mazzo_g2[i];
				mazzo_g2.erase(mazzo_g2.begin() + i);
				cartaTrovata = true;
				break;
			}
	}
}
if (!cartaTrovata){ //se non è possibile giocare una carta "carico", allora, la CPU gioca una briscola alta
	for (int i=0; i<mazzo_g2.size(); i++){
		int punti = calcolaPunteggio(mazzo_g2[i]);
			if (mazzo_g2[i].lettera == cartapescatab.lettera && punti>=10){
				cartagiocata2 = mazzo_g2[i];
				mazzo_g2.erase(mazzo_g2.begin() + i);
				cartaTrovata = true;
				break;
			}
	}
}

// controllo se G1 ha giocato liscio o carico 2-3
bool cartaTrovata = false;

bool LiscioOCarico23 = cartaBriscola(cartagiocata1, cartapescatab);

if (!cartaTrovata && LiscioOCarico23) {
	int migliore = -1; // mentre qua si parte da -1 perchè ancora non è stata trovata una carta
    int forzaMigliore = -1;   // si parte da -1 così che non si può perdere nessun confronto 
		for (int i = 0; i < mazzo_g2.size(); i++) {
        	if (mazzo_g2[i].lettera != cartagiocata1.lettera){
				int forza = forzaCarta(mazzo_g2[i]);
					if (forza > forzaMigliore) {
            			forzaMigliore = forza;
            			migliore = i;
        	}
    	}
    }

    // se trovata una carta valida
    if (migliore != -1) {
        cartagiocata2 = mazzo_g2[migliore];
        mazzo_g2.erase(mazzo_g2.begin() + migliore);
        cartaTrovata = true;
    }
}

//se non è possibile giocare una carta dello stesso seme (dalle più forti a scendere) allora la CPU gioca una carta liscio
if (!cartaTrovata) {
	for (int i = 0; i < mazzo_g2.size(); i++) {
		int punti = calcolaPunteggio(mazzo_g2[i]);
        	if (punti == 0 && mazzo_g2[i].lettera != cartapescatab.lettera) {
				cartagiocata2 = mazzo_g2[i];
            	mazzo_g2.erase(mazzo_g2.begin() + i);
            	cartaTrovata = true;
            	break;
        }
    }
}

// se non è possibile giocare una carta liscio allora la CPU gioca una carta di briscola che sia più bassa del re
if (!cartaTrovata) {
	for (int i = 0; i < mazzo_g2.size(); i++) {
		int punti = calcolaPunteggio(mazzo_g2[i]);
        	if (mazzo_g2[i].lettera == cartapescatab.lettera && punti < 4) {
				cartagiocata2 = mazzo_g2[i];
            	mazzo_g2.erase(mazzo_g2.begin() + i);
            	cartaTrovata = true;
            	break;
        }
    }
}

// se non è possibile giocare una carta di briscola che sia più bassa del re, allora la CPU gioca una carta carico
if (!cartaTrovata) {
    for (int i = 0; i < mazzo_g2.size(); i++) {
        int punti = calcolaPunteggio(mazzo_g2[i]);
        	if (mazzo_g2[i].lettera != cartapescatab.lettera && punti >= 2 && punti <= 4) {
            	cartagiocata2 = mazzo_g2[i];
            	mazzo_g2.erase(mazzo_g2.begin() + i);
            	cartaTrovata = true;
            	break;
        }
    }
}
// se non è possibile giocare una carta carico, allora la CPU gioca una briscola alta
if (!cartaTrovata) {
    for (int i = 0; i < mazzo_g2.size(); i++) {
        int punti = calcolaPunteggio(mazzo_g2[i]);
        	if (mazzo_g2[i].lettera == cartapescatab.lettera && punti >= 10) {
            	cartagiocata2 = mazzo_g2[i];
            	mazzo_g2.erase(mazzo_g2.begin() + i); 
            	cartaTrovata = true;
            	break;
        }
    }
}

// se il GIOCATORE 1 gioca una carta carico (4 punti)

if (calcolaPunteggio(cartagiocata1) == 4) { 
	bool cartaTrovata = false;

//La CPU gioca una carta dello stesso seme (dalle più forti a scendere fino a quella giocata)
    for (int i = 0; i < mazzo_g2.size(); i++) {
        if (mazzo_g2[i].lettera == cartagiocata1.lettera) {
            int forza = forzaCarta(cartagiocata1);
            int forzaCPU = forzaCarta(mazzo_g2[i]);
            	if (forzaCPU >= forza) {
               	 cartagiocata2 = mazzo_g2[i];
                	mazzo_g2.erase(mazzo_g2.begin() + i);
                	cartaTrovata = true;
                	break;
            }
        }
    }

// se non è possibile giocare una carta dello stesso seme, allora gioca una briscola (minore dell'8)
    if (!cartaTrovata) {
        for (int i = 0; i < mazzo_g2.size(); i++) {
        	int punti = calcolaPunteggio(mazzo_g2[i]);
            	if (mazzo_g2[i].lettera == cartapescatab.lettera && punti < 8) {
                	cartagiocata2 = mazzo_g2[i];
                	mazzo_g2.erase(mazzo_g2.begin() + i);
                	cartaTrovata = true;
                	break;
            }
        }
    }

// se non è possibile giocare una briscola minore dell'8, allora gioca una carta liscio (carta che non vale punti e non è di briscola)
    if (!cartaTrovata) {
        for (int i = 0; i < mazzo_g2.size(); i++) {
        	int punti = calcolaPunteggio(mazzo_g2[i]);
            	if (punti == 0 && mazzo_g2[i].lettera != cartapescatab.lettera) {
                	cartagiocata2 = mazzo_g2[i];
                	mazzo_g2.erase(mazzo_g2.begin() + i);
                	cartaTrovata = true;
                	break;
            }
        }
    }

// se non è possibile giocare una carta liscio, allora gioca una briscola (punteggio tra 8 e 10)
    if (!cartaTrovata) {
        for (int i = 0; i < mazzo_g2.size(); i++) {
        	int punti = calcolaPunteggio(mazzo_g2[i]);
            	if (mazzo_g2[i].lettera == cartapescatab.lettera && punti >= 8 && punti <= 10) {
                	cartagiocata2 = mazzo_g2[i];
                	mazzo_g2.erase(mazzo_g2.begin() + i);
                	cartaTrovata = true;
                	break;
            }
        }
    }

// se non è possibile giocare una briscola dall'8 al 10, allora gioca una carta carico (con punteggio tra 2 e 4, ma non di briscola)
    if (!cartaTrovata) {
        for (int i = 0; i < mazzo_g2.size(); i++) {
            int punti = calcolaPunteggio(mazzo_g2[i]);
            if (punti >= 2 && punti <= 4 && mazzo_g2[i].lettera != cartapescatab.lettera) {
                cartagiocata2 = mazzo_g2[i];
                mazzo_g2.erase(mazzo_g2.begin() + i);
                cartaTrovata = true;
                break;
            }
        }
    }

// se non è possibile giocare una carta carico, allora gioca una briscola (punteggio tra 10 e 1)
    if (!cartaTrovata) {
        for (int i = 0; i < mazzo_g2.size(); i++) {
        	int punti = calcolaPunteggio(mazzo_g2[i]);
            	if (mazzo_g2[i].lettera == cartapescatab.lettera && punti >= 10) {
                	cartagiocata2 = mazzo_g2[i];
                	mazzo_g2.erase(mazzo_g2.begin() + i);
                	cartaTrovata = true;
                	break;
            }
        }
    }
}
// Se GIOCATORE 1 gioca una carta carico (dai 4 punti in su)

if (calcolaPunteggio(cartagiocata1) > 4 && cartagiocata1.lettera != cartapescatab.lettera) {
	bool cartaTrovata = false;

// La CPU gioca una carta dello stesso seme più alta
    for (int i = 0; i < mazzo_g2.size(); i++) {
        if (mazzo_g2[i].lettera == cartagiocata1.lettera) {
            int forza = forzaCarta(cartagiocata1);
            int forzaCPU = forzaCarta(mazzo_g2[i]);
            	if (forzaCPU > forza) {
                	cartagiocata2 = mazzo_g2[i];
                	mazzo_g2.erase(mazzo_g2.begin() + i);
                	cartaTrovata = true;
                	break;
            }
        }
    }

// se non è possibile giocare una carta dello stesso seme, allora la CPU gioca una briscola (dalla più bassa in su)
    if (!cartaTrovata) {
        for (int i = 0; i < mazzo_g2.size(); i++) {
            int punti = calcolaPunteggio(mazzo_g2[i]);
            	if (mazzo_g2[i].lettera == cartapescatab.lettera && punti > 0) {
                	cartagiocata2 = mazzo_g2[i];
                	mazzo_g2.erase(mazzo_g2.begin() + i);
                	cartaTrovata = true;
                	break;
            }
        }
    }

// se non è possibile giocare una carta briscola, allora la CPU gioca una carta liscio (che non vale punti e non è di briscola)
    if (!cartaTrovata) {
        for (int i = 0; i < mazzo_g2.size(); i++) {
            int punti = calcolaPunteggio(mazzo_g2[i]);
            	if (punti == 0 && mazzo_g2[i].lettera != cartapescatab.lettera) {
                	cartagiocata2 = mazzo_g2[i];
                	mazzo_g2.erase(mazzo_g2.begin() + i);
                	cartaTrovata = true;
                	break;
            }
        }
    }

// se non è possibile giocare una carta liscio, allora la CPU gioca una carta carico (che vale punti e non è di briscola)
    if (!cartaTrovata) {
        for (int i = 0; i < mazzo_g2.size(); i++) {
            int punti = calcolaPunteggio(mazzo_g2[i]);
            	if (punti > 0 && mazzo_g2[i].lettera != cartapescatab.lettera) {
                	cartagiocata2 = mazzo_g2[i];
                	mazzo_g2.erase(mazzo_g2.begin() + i);
                	cartaTrovata = true;
                	break;
            }
        }
    }
}





}
}
return 0;
}


